{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Information Retrieval Codes with Explanation Practical 1 Practical 2 Practical 3 ... More Coming Very Soon","title":"Home"},{"location":"#information-retrieval-codes-with-explanation","text":"","title":"Information Retrieval Codes with Explanation"},{"location":"#practical-1","text":"","title":"Practical 1"},{"location":"#practical-2","text":"","title":"Practical 2"},{"location":"#practical-3","text":"... More Coming Very Soon","title":"Practical 3"},{"location":"IRP2/","text":"Aim: Write a program to implement Page Rank Algorithm. \u2b07 We are importing networkx for creating a reference page rank order to which we can compare later. 1 import networkx as nx \u2b07 Numpy is a dependency of Matplotlib 1 import numpy as np \u2b07 Pandas is also imported for no reason \ud83d\ude15 1 import pandas as pd \u2b07 Matplotlib is a dependency of Networkx for the graph 1 import matplotlib.pyplot as plt \u2b07 Operator is also imported for no reason \ud83d\ude15 1 import operator \u2b07 Random is imported for generating random values 1 import random as rd \u2b07 nx.gnp_random_graph Returns a Gn,p random graph, also known as an Erd\u0151s-R\u00e9nyi graph or a binomial graph. The Gn,p model chooses each of the possible edges with probability p. here, 25 is the n or number of nodes 0.6 is the probability value directed=True will create a directed graph 1 graph = nx . gnp_random_graph ( 25 , 0.6 , directed = True ) \u2b07 nx.draw() Draws the graph G with Matplotlib. Draw the graph as a simple representation with no node labels or edge labels and using the full Matplotlib figure area and no axis labels by default. See draw_networkx() for more full-featured drawing that allows title, axis labels etc. G (graph): A networkx graph with_labels=True: (optional for label) font_color=\"white: (optional for font color) font_size=12: (optional for font size) node_color=\"purple\" (optional for node color) 1 2 nx . draw ( graph , with_labels = True , font_color = 'white' , font_size = 12 , node_color = 'purple' ) \u2b07 To plot the graph in a window we use plt.show() 1 plt . show () \u2b07 We are storing the count of nodes. 1 2 count = graph . number_of_nodes () print ( count ) 1 25 \u2b07 Listing the graph neighbors with degree 1 1 print ( list ( graph . neighbors ( 1 ))) 1 [0, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 22, 23] \u2b07 rank_dict for storing ranks 1 rank_dict = {} \u2b07 x is the random integer between 0 and 25 1 x = rd . randint ( 0 , 25 ) \u2b07 Here we are initializing rank_dict with 25(0-24) keys with 0 value 1 2 for j in range ( 0 , 25 ): rank_dict [ j ] = 0 \u2b07 we are adding 1 to the random x in dictionary 1 rank_dict [ x ] = rank_dict [ x ] + 1 \u2b07 Main Component of PageRank which computes the ranking of the nodes in the graph G based on the structure of the incoming links. we run this 5,00,000 times whenever the length of neighbours is 0 we randomly choose some other pivot as x otherwise we keep incrementing its rank. 1 2 3 4 5 6 7 8 9 10 for i in range ( 500000 ): list_n = list ( graph . neighbors ( x )) if ( len ( list_n ) == 0 ): x = rd . randint ( 0 , 25 ) rank_dict [ x ] = rank_dict [ x ] + 1 else : x = rd . choice ( list_n ) rank_dict [ x ] = rank_dict [ x ] + 1 print ( \"Random Walk Score Updated\" ) print ( rank_dict ) 1 2 Random Walk Score Updated {0: 26631, 1: 24160, 2: 21452, 3: 17846, 4: 14745, 5: 20613, 6: 14477, 7: 20485, 8: 17741, 9: 14687, 10: 22520, 11: 22676, 12: 23955, 13: 22945, 14: 18242, 15: 19426, 16: 21698, 17: 18471, 18: 22214, 19: 13605, 20: 28412, 21: 16974, 22: 18355, 23: 21216, 24: 16455} \u2b07 Here we are normalizing the values to get a value between 0-1 1 2 3 for j in range ( 0 , 25 ): rank_dict [ j ] = rank_dict [ j ] / 500000 print ( rank_dict ) 1 {0: 0.053262, 1: 0.04832, 2: 0.042904, 3: 0.035692, 4: 0.02949, 5: 0.041226, 6: 0.028954, 7: 0.04097, 8: 0.035482, 9: 0.029374, 10: 0.04504, 11: 0.045352, 12: 0.04791, 13: 0.04589, 14: 0.036484, 15: 0.038852, 16: 0.043396, 17: 0.036942, 18: 0.044428, 19: 0.02721, 20: 0.056824, 21: 0.033948, 22: 0.03671, 23: 0.042432, 24: 0.03291} \u2b07 nx.pagerank(): Returns the PageRank of the nodes in the graph. PageRank computes a ranking of the nodes in the graph G based on the structure of the incoming links. It was originally designed as an algorithm to rank web pages. 1 pagerank = nx . pagerank ( graph ) \u2b07 we are sorting the Networkx pageranked items 1 2 3 pagerank_sorted = sorted ( pagerank . items (), key = lambda v :( v [ 1 ], v [ 0 ]), reverse = True ) \u2b07 We are sorting our algorithm based ranked items 1 2 3 rank_dict_sorted = sorted ( rank_dict . items (), key = lambda v :( v [ 1 ], v [ 0 ]), reverse = True ) \u2b07 Finally comparing the outcomes 1 2 3 4 5 6 print ( \"The order generated by our implementation algorithm is \\n \" ) for i in rank_dict_sorted : print ( i [ 0 ], end = \" \" ) print ( \" \\n\\n The order generated by networkx library is \\n \" ) for i in pagerank_sorted : print ( i [ 0 ], end = \" \" ) 1 2 3 4 5 6 7 The order generated by our implementation algorithm is 20 0 1 12 13 11 10 18 16 2 23 5 7 15 17 22 14 3 8 21 24 4 9 6 19 The order generated by networkx library is 20 0 12 1 13 11 18 10 16 2 23 5 7 15 17 14 22 3 8 21 24 4 9 6 19","title":"Practical 2"},{"location":"IRP2/#aim-write-a-program-to-implement-page-rank-algorithm","text":"","title":"Aim: Write a program to implement Page Rank Algorithm."},{"location":"IRP2/#we-are-importing-networkx-for-creating-a-reference-page-rank-order-to-which-we-can-compare-later","text":"1 import networkx as nx","title":"\u2b07 We are importing networkx for creating a reference page rank order to which we can compare later."},{"location":"IRP2/#numpy-is-a-dependency-of-matplotlib","text":"1 import numpy as np","title":"\u2b07 Numpy is a dependency of Matplotlib"},{"location":"IRP2/#pandas-is-also-imported-for-no-reason","text":"1 import pandas as pd","title":"\u2b07 Pandas is also imported for no reason \ud83d\ude15"},{"location":"IRP2/#matplotlib-is-a-dependency-of-networkx-for-the-graph","text":"1 import matplotlib.pyplot as plt","title":"\u2b07 Matplotlib is a dependency of Networkx for the graph"},{"location":"IRP2/#operator-is-also-imported-for-no-reason","text":"1 import operator","title":"\u2b07 Operator is also imported for no reason \ud83d\ude15"},{"location":"IRP2/#random-is-imported-for-generating-random-values","text":"1 import random as rd","title":"\u2b07 Random is imported for generating random values"},{"location":"IRP2/#nxgnp_random_graph-returns-a-gnp-random-graph-also-known-as-an-erdos-renyi-graph-or-a-binomial-graph-the-gnp-model-chooses-each-of-the-possible-edges-with-probability-p","text":"here, 25 is the n or number of nodes 0.6 is the probability value directed=True will create a directed graph 1 graph = nx . gnp_random_graph ( 25 , 0.6 , directed = True )","title":"\u2b07 nx.gnp_random_graph Returns a Gn,p random graph, also known as an Erd\u0151s-R\u00e9nyi graph or a binomial graph. The Gn,p model chooses each of the possible edges with probability p."},{"location":"IRP2/#nxdraw-draws-the-graph-g-with-matplotlib","text":"Draw the graph as a simple representation with no node labels or edge labels and using the full Matplotlib figure area and no axis labels by default. See draw_networkx() for more full-featured drawing that allows title, axis labels etc. G (graph): A networkx graph with_labels=True: (optional for label) font_color=\"white: (optional for font color) font_size=12: (optional for font size) node_color=\"purple\" (optional for node color) 1 2 nx . draw ( graph , with_labels = True , font_color = 'white' , font_size = 12 , node_color = 'purple' )","title":"\u2b07 nx.draw() Draws the graph G with Matplotlib."},{"location":"IRP2/#to-plot-the-graph-in-a-window-we-use-pltshow","text":"1 plt . show ()","title":"\u2b07 To plot the graph in a window we use plt.show()"},{"location":"IRP2/#we-are-storing-the-count-of-nodes","text":"1 2 count = graph . number_of_nodes () print ( count ) 1 25","title":"\u2b07 We are storing the count of nodes."},{"location":"IRP2/#listing-the-graph-neighbors-with-degree-1","text":"1 print ( list ( graph . neighbors ( 1 ))) 1 [0, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 22, 23]","title":"\u2b07 Listing the graph neighbors with degree 1"},{"location":"IRP2/#rank_dict-for-storing-ranks","text":"1 rank_dict = {}","title":"\u2b07 rank_dict for storing ranks"},{"location":"IRP2/#x-is-the-random-integer-between-0-and-25","text":"1 x = rd . randint ( 0 , 25 )","title":"\u2b07 x is the random integer between 0 and 25"},{"location":"IRP2/#here-we-are-initializing-rank_dict-with-250-24-keys-with-0-value","text":"1 2 for j in range ( 0 , 25 ): rank_dict [ j ] = 0","title":"\u2b07 Here we are initializing rank_dict with 25(0-24) keys with 0 value"},{"location":"IRP2/#we-are-adding-1-to-the-random-x-in-dictionary","text":"1 rank_dict [ x ] = rank_dict [ x ] + 1","title":"\u2b07 we are adding 1 to the random x in dictionary"},{"location":"IRP2/#main-component-of-pagerank-which-computes-the-ranking-of-the-nodes-in-the-graph-g-based-on-the-structure-of-the-incoming-links-we-run-this-500000-times-whenever-the-length-of-neighbours-is-0-we-randomly-choose-some-other-pivot-as-x-otherwise-we-keep-incrementing-its-rank","text":"1 2 3 4 5 6 7 8 9 10 for i in range ( 500000 ): list_n = list ( graph . neighbors ( x )) if ( len ( list_n ) == 0 ): x = rd . randint ( 0 , 25 ) rank_dict [ x ] = rank_dict [ x ] + 1 else : x = rd . choice ( list_n ) rank_dict [ x ] = rank_dict [ x ] + 1 print ( \"Random Walk Score Updated\" ) print ( rank_dict ) 1 2 Random Walk Score Updated {0: 26631, 1: 24160, 2: 21452, 3: 17846, 4: 14745, 5: 20613, 6: 14477, 7: 20485, 8: 17741, 9: 14687, 10: 22520, 11: 22676, 12: 23955, 13: 22945, 14: 18242, 15: 19426, 16: 21698, 17: 18471, 18: 22214, 19: 13605, 20: 28412, 21: 16974, 22: 18355, 23: 21216, 24: 16455}","title":"\u2b07 Main Component of PageRank which computes the ranking of the nodes in the graph G based on the structure of the incoming links. we run this 5,00,000 times whenever the length of neighbours is 0 we randomly choose some other pivot as x otherwise we keep incrementing its rank."},{"location":"IRP2/#here-we-are-normalizing-the-values-to-get-a-value-between-0-1","text":"1 2 3 for j in range ( 0 , 25 ): rank_dict [ j ] = rank_dict [ j ] / 500000 print ( rank_dict ) 1 {0: 0.053262, 1: 0.04832, 2: 0.042904, 3: 0.035692, 4: 0.02949, 5: 0.041226, 6: 0.028954, 7: 0.04097, 8: 0.035482, 9: 0.029374, 10: 0.04504, 11: 0.045352, 12: 0.04791, 13: 0.04589, 14: 0.036484, 15: 0.038852, 16: 0.043396, 17: 0.036942, 18: 0.044428, 19: 0.02721, 20: 0.056824, 21: 0.033948, 22: 0.03671, 23: 0.042432, 24: 0.03291}","title":"\u2b07 Here we are normalizing the values to get a value between 0-1"},{"location":"IRP2/#nxpagerank","text":"Returns the PageRank of the nodes in the graph. PageRank computes a ranking of the nodes in the graph G based on the structure of the incoming links. It was originally designed as an algorithm to rank web pages. 1 pagerank = nx . pagerank ( graph )","title":"\u2b07 nx.pagerank():"},{"location":"IRP2/#we-are-sorting-the-networkx-pageranked-items","text":"1 2 3 pagerank_sorted = sorted ( pagerank . items (), key = lambda v :( v [ 1 ], v [ 0 ]), reverse = True )","title":"\u2b07 we are sorting the Networkx pageranked items"},{"location":"IRP2/#we-are-sorting-our-algorithm-based-ranked-items","text":"1 2 3 rank_dict_sorted = sorted ( rank_dict . items (), key = lambda v :( v [ 1 ], v [ 0 ]), reverse = True )","title":"\u2b07 We are sorting our algorithm based ranked items"},{"location":"IRP2/#finally-comparing-the-outcomes","text":"1 2 3 4 5 6 print ( \"The order generated by our implementation algorithm is \\n \" ) for i in rank_dict_sorted : print ( i [ 0 ], end = \" \" ) print ( \" \\n\\n The order generated by networkx library is \\n \" ) for i in pagerank_sorted : print ( i [ 0 ], end = \" \" ) 1 2 3 4 5 6 7 The order generated by our implementation algorithm is 20 0 1 12 13 11 10 18 16 2 23 5 7 15 17 22 14 3 8 21 24 4 9 6 19 The order generated by networkx library is 20 0 12 1 13 11 18 10 16 2 23 5 7 15 17 14 22 3 8 21 24 4 9 6 19","title":"\u2b07 Finally comparing the outcomes"},{"location":"IRP3/","text":"Aim: Implement Dynamic programming algorithm for computing the edit distance betweenstrings s1 and s2. (Hint. Levenshtein Distance) Code 1 \u2b07 creating a function to find Levenshtein distance between two strings based on the strings and their lengths 1 2 3 4 5 6 7 def dist ( X , m , Y , n ): if ( m == 0 ): return n if ( n == 0 ): return m cost = 0 if ( X [ m - 1 ] == Y [ n - 1 ]) else 1 return min ( dist ( X , m - 1 , Y , n ) + 1 , #Remove dist ( X , m , Y , n - 1 ) + 1 , #Insert dist ( X , m - 1 , Y , n - 1 ) + cost ) #Replace 1 X = \"python\" 1 Y = \"thons\" 1 2 print ( \"The Levenshtein distance is :\" , dist ( X , len ( X ), Y , len ( Y ))) 1 The Levenshtein distance is : 3 Code 2 \u2b07 Pyrix is imported to be used instead of python lists as it will create a beautiful square matrix in output 1 import pyrix as px \u2b07 EditDistance calculator function using matrices 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def editDistDP ( str1 , str2 ): m = len ( str1 ) n = len ( str2 ) dp = px . zeroMatrix ( nrow = m + 1 , ncol = n + 1 ) #dp=[[0 for x in range(n+1)] for x in range(m+1)] print ( \"Intital Matrix:\" ) print ( dp ) for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i elif str1 [ i - 1 ] == str2 [ j - 1 ]: dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] else : dp [ i ][ j ] = 1 + min ( dp [ i ][ j - 1 ], #Insert dp [ i - 1 ][ j ], #Remove dp [ i - 1 ][ j - 1 ]) # Replace print ( \"Final Matrix\" ) print ( dp ) return dp [ m ][ n ] 1 str1 = \"hello\" 1 str2 = \"yellow\" 1 print ( \"Distance between two strings is:\" , editDistDP ( str1 , str2 )) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Intital Matrix: Matrix: [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] Dimensions :6x7 Final Matrix Matrix: [0, 1, 2, 3, 4, 5, 6] [1, 1, 2, 3, 4, 5, 6] [2, 2, 1, 2, 3, 4, 5] [3, 3, 2, 1, 2, 3, 4] [4, 4, 3, 2, 1, 2, 3] [5, 5, 4, 3, 2, 1, 2] Dimensions :6x7 Distance between two strings is: 2","title":"Practical 3"},{"location":"IRP3/#aim-implement-dynamic-programming-algorithm-for-computing-the-edit-distance-betweenstrings-s1-and-s2-hint-levenshtein-distance","text":"","title":"Aim: Implement Dynamic programming algorithm for computing the edit distance betweenstrings s1 and s2. (Hint. Levenshtein Distance)"},{"location":"IRP3/#code-1","text":"","title":"Code 1"},{"location":"IRP3/#creating-a-function-to-find-levenshtein-distance-between-two-strings-based-on-the-strings-and-their-lengths","text":"1 2 3 4 5 6 7 def dist ( X , m , Y , n ): if ( m == 0 ): return n if ( n == 0 ): return m cost = 0 if ( X [ m - 1 ] == Y [ n - 1 ]) else 1 return min ( dist ( X , m - 1 , Y , n ) + 1 , #Remove dist ( X , m , Y , n - 1 ) + 1 , #Insert dist ( X , m - 1 , Y , n - 1 ) + cost ) #Replace 1 X = \"python\" 1 Y = \"thons\" 1 2 print ( \"The Levenshtein distance is :\" , dist ( X , len ( X ), Y , len ( Y ))) 1 The Levenshtein distance is : 3","title":"\u2b07 creating a function to find Levenshtein distance between two strings based on the strings and their lengths"},{"location":"IRP3/#code-2","text":"","title":"Code 2"},{"location":"IRP3/#pyrix-is-imported-to-be-used-instead-of-python-lists-as-it-will-create-a-beautiful-square-matrix-in-output","text":"1 import pyrix as px","title":"\u2b07 Pyrix is imported to be used instead of python lists as it will create a beautiful square matrix in output"},{"location":"IRP3/#editdistance-calculator-function-using-matrices","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def editDistDP ( str1 , str2 ): m = len ( str1 ) n = len ( str2 ) dp = px . zeroMatrix ( nrow = m + 1 , ncol = n + 1 ) #dp=[[0 for x in range(n+1)] for x in range(m+1)] print ( \"Intital Matrix:\" ) print ( dp ) for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i elif str1 [ i - 1 ] == str2 [ j - 1 ]: dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] else : dp [ i ][ j ] = 1 + min ( dp [ i ][ j - 1 ], #Insert dp [ i - 1 ][ j ], #Remove dp [ i - 1 ][ j - 1 ]) # Replace print ( \"Final Matrix\" ) print ( dp ) return dp [ m ][ n ] 1 str1 = \"hello\" 1 str2 = \"yellow\" 1 print ( \"Distance between two strings is:\" , editDistDP ( str1 , str2 )) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Intital Matrix: Matrix: [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 0, 0, 0, 0] Dimensions :6x7 Final Matrix Matrix: [0, 1, 2, 3, 4, 5, 6] [1, 1, 2, 3, 4, 5, 6] [2, 2, 1, 2, 3, 4, 5] [3, 3, 2, 1, 2, 3, 4] [4, 4, 3, 2, 1, 2, 3] [5, 5, 4, 3, 2, 1, 2] Dimensions :6x7 Distance between two strings is: 2","title":"\u2b07 EditDistance calculator function using matrices"},{"location":"IR_P1/","text":"IR Practical 1 Aim : Write a program to demonstrate bitwise operation. Integer Value Binary Value a 2 0010 b 4 0100 AND 0 0000 OR 6 0110 NOT(2) -3 -1100 Lshift(2) 1 0001 Rshift(2) 4 0100 Part A :Binary Bitwise Operators \u2b07 We are imporitng sys for conversion of integers to binary (this is optional). 1 import sys \u2b07 This Function is just a quick method to convert out integer into Binary (Makes it easier to understand) 1 2 def i2b ( in1 ): return bin ( int . from_bytes ( bytes ( str ( in1 ), encoding = \"utf8\" ), byteorder = sys . byteorder )) \u2b07 Taking Input for first value 1 a = int ( input ( \"enter the first value\" )) 1 enter the first value 2 \u2b07 Binary Representation of first value 1 i2b ( a ) 1 '0b110010' \u2b07 Taking input for second value 1 b = int ( input ( \"Enter the second value\" )) 1 Enter the second value 4 \u2b07 Binary Representation for second value 1 i2b ( b ) 1 '0b110100' 1 2 c1 = a & b print ( \"The Bitwise AND of a and b \\n Binary:\" , i2b ( c1 ), \" \\n Integer:\" , c1 ) 1 2 3 The Bitwise AND of a and b Binary: 0b110000 Integer: 0 1 2 c2 = a | b print ( \"The Bitwise OR of a and b is \\n Binary:\" , i2b ( c2 ), \" \\n Integer:\" , c2 ) 1 2 3 The Bitwise OR of a and b is Binary: 0b110110 Integer: 6 1 2 c3 = a ^ b print ( \"The Bitwise EXOR of a and b is \\n Binary:\" , i2b ( c3 ), \" \\n Integer:\" , c3 ) 1 2 3 The Bitwise EXOR of a and b is Binary: 0b110110 Integer: 6 1 2 c4 =~ a & 255 # Python Calculates Negation on 8bit unsigned integers. print ( \"The Bitwise NOT of a is \\n Binary:\" , i2b ( c4 ), \" \\n Integer:\" , c4 ) 1 2 3 The Bitwise NOT of a is Binary: 0b1100110011010100110010 Integer: 253 1 2 c5 =~ b & 255 print ( \"The Bitwise NOT of b is \\n Binary:\" , i2b ( c5 ), \" \\n Integer:\" , c5 ) 1 2 3 The Bitwise NOT of b is Binary: 0b1100010011010100110010 Integer: 251 1 2 c6 = a >> 1 print ( \"The Left Shift of a is \\n Binary:\" , i2b ( c6 ), \" \\n Integer:\" , c6 ) 1 2 3 The Left Shift of a is Binary: 0b110001 Integer: 1 1 2 c7 = b >> 1 print ( \"The Left Shift of b is \\n Binary:\" , i2b ( c7 ), \" \\n Integer:\" , c7 ) 1 2 3 The Left Shift of b is Binary: 0b110010 Integer: 2 1 2 c8 = a << 1 print ( \"The Right Shift of a is \\n Binary:\" , i2b ( c8 ), \" \\n Integer:\" , c8 ) 1 2 3 The Right Shift of a is Binary: 0b110100 Integer: 4 1 2 c9 = b << 1 print ( \"The Right Shift of b is \\n Binary:\" , i2b ( c9 ), \" \\n Integer:\" , c9 ) 1 2 3 The Right Shift of b is Binary: 0b111000 Integer: 8 Part B :Boolean Operation On Text \u2b07 Importing Pandas for creating dataFrame of Word occourences 1 import pandas as pd \u2b07 We are importing CountVectorizer to Convert a collection of text documents to a matrix of token counts 1 from sklearn.feature_extraction.text import CountVectorizer \u2b07 creating a variable with some sentences which can also be documents 1 2 3 4 5 6 corpus = [ 'We are doing IR practicals' , 'IR is interesting subject' , 'IR subject is a part of computer science' , 'computer science is the category of practicals' ] \u2b07 Creating an object of CountVectorizer class 1 vectorizer = CountVectorizer () \u2b07 Fit followed by transform will learn the vocabulary dictionary and return document-term matrix. 1 x = vectorizer . fit_transform ( corpus ) 1 print ( 'Fit Transform is : \\n ' , x . toarray ()) 1 2 3 4 5 Fit Transform is : [[1 0 0 1 0 1 0 0 0 1 0 0 0 1] [0 0 0 0 1 1 1 0 0 0 0 1 0 0] [0 0 1 0 0 1 1 1 1 0 1 1 0 0] [0 1 1 0 0 0 1 1 0 1 1 0 1 0]] \u2b07 Here we create a DataFrame of the above Fit Transform Matrix with headings as the individual words. 1 df = pd . DataFrame ( x . toarray (), columns = vectorizer . get_feature_names ()) 1 print ( \"Generated DataFrame is : \\n \" , df ) 1 2 3 4 5 6 7 8 9 10 11 12 Generated DataFrame is : are category computer doing interesting ir is of part practicals \\ 0 1 0 0 1 0 1 0 0 0 1 1 0 0 0 0 1 1 1 0 0 0 2 0 0 1 0 0 1 1 1 1 0 3 0 1 1 0 0 0 1 1 0 1 science subject the we 0 0 0 0 1 1 0 1 0 0 2 1 1 0 0 3 1 0 1 0 1 anddata = df [( df [ 'ir' ] == 1 ) & ( df [ 'practicals' ] == 1 )] 1 print ( \"Indices where both 'ir' and 'practicals' are present are:\" , anddata . index . tolist ()) 1 Indices where both 'ir' and 'practicals' are present are: [0] 1 ordata = df [( df [ 'ir' ] == 1 ) | ( df [ 'practicals' ] == 1 )] 1 print ( \"Indices where 'ir' or 'practicals' are present are:\" , ordata . index . tolist ()) 1 Indices where 'ir' or 'practicals' are present are: [0, 1, 2, 3] 1 notdata = df [( df [ 'ir' ] != 1 )] 1 print ( \"Indices where 'ir' is not are present are:\" , notdata . index . tolist ()) 1 Indices where 'ir' is not are present are: [3]","title":"Practical 1"},{"location":"IR_P1/#ir-practical-1","text":"","title":"IR Practical 1"},{"location":"IR_P1/#aim-write-a-program-to-demonstrate-bitwise-operation","text":"Integer Value Binary Value a 2 0010 b 4 0100 AND 0 0000 OR 6 0110 NOT(2) -3 -1100 Lshift(2) 1 0001 Rshift(2) 4 0100","title":"Aim : Write a program to demonstrate bitwise operation."},{"location":"IR_P1/#part-a-binary-bitwise-operators","text":"","title":"Part A :Binary Bitwise Operators"},{"location":"IR_P1/#we-are-imporitng-sys-for-conversion-of-integers-to-binary-this-is-optional","text":"1 import sys","title":"\u2b07 We are imporitng sys for conversion of integers to binary (this is optional)."},{"location":"IR_P1/#this-function-is-just-a-quick-method-to-convert-out-integer-into-binary-makes-it-easier-to-understand","text":"1 2 def i2b ( in1 ): return bin ( int . from_bytes ( bytes ( str ( in1 ), encoding = \"utf8\" ), byteorder = sys . byteorder ))","title":"\u2b07 This Function is just a quick method to convert out integer into Binary (Makes it easier to understand)"},{"location":"IR_P1/#taking-input-for-first-value","text":"1 a = int ( input ( \"enter the first value\" )) 1 enter the first value 2","title":"\u2b07 Taking Input for first value"},{"location":"IR_P1/#binary-representation-of-first-value","text":"1 i2b ( a ) 1 '0b110010'","title":"\u2b07 Binary Representation of first value"},{"location":"IR_P1/#taking-input-for-second-value","text":"1 b = int ( input ( \"Enter the second value\" )) 1 Enter the second value 4","title":"\u2b07 Taking input for second value"},{"location":"IR_P1/#binary-representation-for-second-value","text":"1 i2b ( b ) 1 '0b110100' 1 2 c1 = a & b print ( \"The Bitwise AND of a and b \\n Binary:\" , i2b ( c1 ), \" \\n Integer:\" , c1 ) 1 2 3 The Bitwise AND of a and b Binary: 0b110000 Integer: 0 1 2 c2 = a | b print ( \"The Bitwise OR of a and b is \\n Binary:\" , i2b ( c2 ), \" \\n Integer:\" , c2 ) 1 2 3 The Bitwise OR of a and b is Binary: 0b110110 Integer: 6 1 2 c3 = a ^ b print ( \"The Bitwise EXOR of a and b is \\n Binary:\" , i2b ( c3 ), \" \\n Integer:\" , c3 ) 1 2 3 The Bitwise EXOR of a and b is Binary: 0b110110 Integer: 6 1 2 c4 =~ a & 255 # Python Calculates Negation on 8bit unsigned integers. print ( \"The Bitwise NOT of a is \\n Binary:\" , i2b ( c4 ), \" \\n Integer:\" , c4 ) 1 2 3 The Bitwise NOT of a is Binary: 0b1100110011010100110010 Integer: 253 1 2 c5 =~ b & 255 print ( \"The Bitwise NOT of b is \\n Binary:\" , i2b ( c5 ), \" \\n Integer:\" , c5 ) 1 2 3 The Bitwise NOT of b is Binary: 0b1100010011010100110010 Integer: 251 1 2 c6 = a >> 1 print ( \"The Left Shift of a is \\n Binary:\" , i2b ( c6 ), \" \\n Integer:\" , c6 ) 1 2 3 The Left Shift of a is Binary: 0b110001 Integer: 1 1 2 c7 = b >> 1 print ( \"The Left Shift of b is \\n Binary:\" , i2b ( c7 ), \" \\n Integer:\" , c7 ) 1 2 3 The Left Shift of b is Binary: 0b110010 Integer: 2 1 2 c8 = a << 1 print ( \"The Right Shift of a is \\n Binary:\" , i2b ( c8 ), \" \\n Integer:\" , c8 ) 1 2 3 The Right Shift of a is Binary: 0b110100 Integer: 4 1 2 c9 = b << 1 print ( \"The Right Shift of b is \\n Binary:\" , i2b ( c9 ), \" \\n Integer:\" , c9 ) 1 2 3 The Right Shift of b is Binary: 0b111000 Integer: 8","title":"\u2b07 Binary Representation for second value"},{"location":"IR_P1/#part-b-boolean-operation-on-text","text":"","title":"Part B :Boolean Operation On Text"},{"location":"IR_P1/#importing-pandas-for-creating-dataframe-of-word-occourences","text":"1 import pandas as pd","title":"\u2b07 Importing Pandas for creating dataFrame of Word occourences"},{"location":"IR_P1/#we-are-importing-countvectorizer-to-convert-a-collection-of-text-documents-to-a-matrix-of-token-counts","text":"1 from sklearn.feature_extraction.text import CountVectorizer","title":"\u2b07 We are importing CountVectorizer to Convert a collection of text documents to a matrix of token counts"},{"location":"IR_P1/#creating-a-variable-with-some-sentences-which-can-also-be-documents","text":"1 2 3 4 5 6 corpus = [ 'We are doing IR practicals' , 'IR is interesting subject' , 'IR subject is a part of computer science' , 'computer science is the category of practicals' ]","title":"\u2b07 creating a variable with some sentences which can also be documents"},{"location":"IR_P1/#creating-an-object-of-countvectorizer-class","text":"1 vectorizer = CountVectorizer ()","title":"\u2b07 Creating an object of CountVectorizer class"},{"location":"IR_P1/#fit-followed-by-transform-will-learn-the-vocabulary-dictionary-and-return-document-term-matrix","text":"1 x = vectorizer . fit_transform ( corpus ) 1 print ( 'Fit Transform is : \\n ' , x . toarray ()) 1 2 3 4 5 Fit Transform is : [[1 0 0 1 0 1 0 0 0 1 0 0 0 1] [0 0 0 0 1 1 1 0 0 0 0 1 0 0] [0 0 1 0 0 1 1 1 1 0 1 1 0 0] [0 1 1 0 0 0 1 1 0 1 1 0 1 0]]","title":"\u2b07 Fit followed by transform will learn the vocabulary dictionary and return document-term matrix."},{"location":"IR_P1/#here-we-create-a-dataframe-of-the-above-fit-transform-matrix-with-headings-as-the-individual-words","text":"1 df = pd . DataFrame ( x . toarray (), columns = vectorizer . get_feature_names ()) 1 print ( \"Generated DataFrame is : \\n \" , df ) 1 2 3 4 5 6 7 8 9 10 11 12 Generated DataFrame is : are category computer doing interesting ir is of part practicals \\ 0 1 0 0 1 0 1 0 0 0 1 1 0 0 0 0 1 1 1 0 0 0 2 0 0 1 0 0 1 1 1 1 0 3 0 1 1 0 0 0 1 1 0 1 science subject the we 0 0 0 0 1 1 0 1 0 0 2 1 1 0 0 3 1 0 1 0 1 anddata = df [( df [ 'ir' ] == 1 ) & ( df [ 'practicals' ] == 1 )] 1 print ( \"Indices where both 'ir' and 'practicals' are present are:\" , anddata . index . tolist ()) 1 Indices where both 'ir' and 'practicals' are present are: [0] 1 ordata = df [( df [ 'ir' ] == 1 ) | ( df [ 'practicals' ] == 1 )] 1 print ( \"Indices where 'ir' or 'practicals' are present are:\" , ordata . index . tolist ()) 1 Indices where 'ir' or 'practicals' are present are: [0, 1, 2, 3] 1 notdata = df [( df [ 'ir' ] != 1 )] 1 print ( \"Indices where 'ir' is not are present are:\" , notdata . index . tolist ()) 1 Indices where 'ir' is not are present are: [3]","title":"\u2b07 Here we create a DataFrame of the above Fit Transform Matrix with headings as the individual words."}]}